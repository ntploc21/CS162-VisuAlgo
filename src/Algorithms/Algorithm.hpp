#ifndef CORE_ALGORITHMS_LINKEDLIST_ALGORITHM_HPP
#define CORE_ALGORITHMS_LINKEDLIST_ALGORITHM_HPP

#include <algorithm>
#include <cassert>
#include <chrono>
#include <functional>
#include <map>
#include <random>
#include <sstream>
#include <string>
#include <vector>

#include "Animation/AnimationController.hpp"
#include "Animation/AnimationFactory.hpp"
#include "Components/Common/CodeHighlighter.hpp"
#include "Utils/Utils.hpp"

namespace Algorithm {
    /**
     * @brief Base class for all algorithms (which is used to generate
     * step-by-step instructions for visualization)
     * @tparam GUIAlgorithm
     * @tparam AnimationState
     */
    template< typename GUIAlgorithm, typename AnimationState >
    class Algorithm {
    public:
        /**
         * @brief Construct a new Algorithm object
         * @param codeHighlighter
         * @param animController
         * @param fonts
         */
        Algorithm(GUIComponent::CodeHighlighter::Ptr codeHighlighter,
                  typename Animation::AnimationController< AnimationState >::Ptr
                      animController,
                  FontHolder* fonts);

        /**
         * @brief Construct a new Algorithm object
         */
        Algorithm();

        /**
         * @brief Destroy the Algorithm object
         */
        ~Algorithm();

    protected:
        /**
         * @brief Visualizer for the algorithm (which is used to draw animation
         * generated by the algorithm)
         */
        GUIAlgorithm visualizer;

        /**
         * @brief Code highlighter for the algorithm (which is used to highlight
         * the currently running line code in the algorithm)
         */
        GUIComponent::CodeHighlighter::Ptr codeHighlighter;

        /**
         * @brief Animation controller for the algorithm (which is used to
         * control the animation generated by the algorithm)
         * @note This Algorithm class is mainly use the animation controller to
         * add animation for the algorithm
         */
        typename Animation::AnimationController< AnimationState >::Ptr
            animController;

    public:
        /**
         * @brief Initialize an empty data structure, and generate animation
         */
        virtual void Empty();

        /**
         * @brief Initialize a data structure with random values input, and then
         * generate animation
         */
        virtual void Random();

        /**
         * @brief Initialize a fixed size data structure with random values
         * input, and then generate animation
         * @param N the size of the data structure
         */
        virtual void RandomFixedSize(int N);

        /**
         * @brief Initialize a data structure with input from user, and then
         * generate animation
         * @param input the input from user
         */
        virtual void UserDefined(std::string input);

        /**
         * @brief Initialize a data structure with input from external file
         * (which is used to store the input), and then generate animation
         * @param path the path to the external file
         */
        virtual void ReadFromExternalFile(std::string path);

    protected:
        /**
         * @brief Apply an input to the data structure, it will then generate
         * the animation
         * @extends This function is used to apply an input (which is an
         * std::vector< int >) to the data structure, used by other
         * initialization functions
         * @param input the input (in std::vector< int >) to be applied to the
         * data structure
         * @param nMaxSize the maximum size of the data structure, if the input
         * size is larger than nMaxSize, the input will be truncated to nMaxSize
         */
        virtual void ApplyInput(std::vector< int > input,
                                std::size_t nMaxSize = 10);

    protected:
        /**
         * @brief Generate an empty input, this is used to generate the input
         * for ```Empty()```
         * @return std::vector< int > the empty input
         */
        std::vector< int > EmptyGenerator();

        /**
         * @brief Generate a random input, this is used to generate the input
         * for ```Random()```
         * @return std::vector< int > the random input
         */
        std::vector< int > RandomGenerator();

        /**
         * @brief Generate a random input with fixed size, this is used to
         * generate the input for ```RandomFixedSize()```
         * @param nSize the size of the input
         * @return std::vector< int > the random input with fixed size
         */
        std::vector< int > RandomFixedSizeGenerator(int nSize);

        /**
         * @brief Generate an input from user, this is used to generate the
         * input for ```UserDefined()```
         * @param input the input from user
         * @return std::vector< int > the input from user
         */
        std::vector< int > UserDefinedGenerator(std::string input);

        /**
         * @brief Parse the input from external file, this is used to generate
         * the input for ```ReadFromExternalFile()```
         * @param inputFile the path to the external file
         * @return std::vector< int > the input from external file
         */
        std::vector< int > ReadFromFileGenerator(std::string inputFile);

    protected:
        /**
         * @brief Generate the relayout animation (which reposition the data
         * structure to a new position on the screen)
         * @param newPosition the new position of the data structure
         */
        virtual void GenerateRelayoutAnimation(Vector2 newPosition);

        /**
         * @brief Generate an animation (which only contains the metadata of the
         * animation, such as the duration, the highlight line, and the action
         * description, but not the actual animation)
         * @param duration the duration of the animation
         * @param highlightLine the line to be highlighted in the code
         * highlighter (if the line is -1, then no line will be highlighted)
         * @param actionDescription the description of the action (which is used
         * to display in the animation)
         * @return AnimationState the empty animation state (which currently
         * only contains the metadata of the animation)
         */
        virtual AnimationState GenerateAnimation(float duration,
                                                 int highlightLine,
                                                 std::string actionDescription);

        /**
         * @brief Clear the animation controller and the code highlighter, act
         * as a helper function for initialize a new instruction
         * @note This function is used to clear the animation controller and the
         * code highlighter, and then initialize a new instruction
         */
        virtual void InitAction(std::vector< std::string > code);
    };
};  // namespace Algorithm

template< typename GUIAlgorithm, typename AnimationState >
inline Algorithm::Algorithm< GUIAlgorithm, AnimationState >::Algorithm(
    GUIComponent::CodeHighlighter::Ptr codeHighlighter,
    typename Animation::AnimationController< AnimationState >::Ptr
        animController,
    FontHolder* fonts)
    : codeHighlighter(codeHighlighter), animController(animController),
      visualizer(GUIAlgorithm(fonts)) {
    // visualizer.SetPosition(0, 150);
}

template< typename GUIAlgorithm, typename AnimationState >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::Algorithm() {}

template< typename GUIAlgorithm, typename AnimationState >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::~Algorithm() {}

template< typename GUIAlgorithm, typename AnimationState >
std::vector< int >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::EmptyGenerator() {
    return std::vector< int >();
}

template< typename GUIAlgorithm, typename AnimationState >
std::vector< int >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::RandomGenerator() {
    int nSize = Utils::Rand(1, 10);
    // params["nSize"] = (char)(nSize + '0');
    return RandomFixedSizeGenerator(nSize);
}

template< typename GUIAlgorithm, typename AnimationState >
std::vector< int >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::RandomFixedSizeGenerator(
    int nSize) {
    std::vector< int > answer(nSize);
    for (int& v : answer) v = Utils::Rand(1, 99);
    return answer;
}

template< typename GUIAlgorithm, typename AnimationState >
std::vector< int >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::UserDefinedGenerator(
    std::string input) {
    bool canParse =
        (!input.empty() &&
         std::all_of(
             input.begin(), input.end(),
             [](char c) { return ('0' <= c && c <= '9') || (c == ','); }) &&
         input.back() != ',');
    if (!canParse) return EmptyGenerator();

    std::vector< int > answer;

    std::istringstream f(input);
    std::string s;
    while (std::getline(f, s, ',')) {
        try {
            answer.push_back(atoi(s.c_str()));
        } catch (char* e) {
        }
    }
    return answer;
}

template< typename GUIAlgorithm, typename AnimationState >
std::vector< int >
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::ReadFromFileGenerator(
    std::string inputFile) {
    // will be implemented later
    return std::vector< int >();
}

template< typename GUIAlgorithm, typename AnimationState >
inline void
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::GenerateRelayoutAnimation(
    Vector2 newPosition) {
    AnimationState animRelayout =
        GenerateAnimation(0.5, -1,
                          "Re-layout the Linked List for visualization "
                          "(not in the actual Linked "
                          "List).\nThe whole process is still O(1).");
    animRelayout.SetAnimation(
        [this, newPosition](GUIAlgorithm srcDS, float playingAt, Vector2 base) {
            Vector2 newPos = srcDS.GetPosition();
            newPos.x += (newPosition.x - newPos.x) * playingAt;
            newPos.y += (newPosition.y - newPos.y) * playingAt;
            srcDS.SetPosition(newPos);

            srcDS.Draw(base, playingAt);

            return srcDS;
        });
    animController->AddAnimation(animRelayout);
}

template< typename GUIAlgorithm, typename AnimationState >
AnimationState
Algorithm::Algorithm< GUIAlgorithm, AnimationState >::GenerateAnimation(
    float duration, int highlightLine, std::string actionDescription) {
    AnimationState animation;
    animation.SetDuration(duration);
    animation.SetHighlightLine(highlightLine);
    animation.SetSourceDataStructure(visualizer);
    animation.SetActionDescription(actionDescription);
    return animation;
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::InitAction(
    std::vector< std::string > code) {
    animController->Reset();
    // animController->Pause();
    animController->InteractionAllow();
    animController->Clear();
    codeHighlighter->AddCode(code);
    codeHighlighter->SetShowCode(true);
    codeHighlighter->SetShowAction(true);
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::Empty() {
    ApplyInput(EmptyGenerator());
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::Random() {
    ApplyInput(RandomGenerator());
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::RandomFixedSize(
    int N) {
    ApplyInput(RandomFixedSizeGenerator(N));
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::UserDefined(
    std::string input) {
    ApplyInput(UserDefinedGenerator(input));
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::ReadFromExternalFile(
    std::string path) {
    ApplyInput(ReadFromFileGenerator(path));
}

template< typename GUIAlgorithm, typename AnimationState >
void Algorithm::Algorithm< GUIAlgorithm, AnimationState >::ApplyInput(
    std::vector< int > input, std::size_t nMaxSize) {
    if (input.size() > nMaxSize) input.resize(nMaxSize);
    InitAction({});

    codeHighlighter->SetShowCode(false);
    codeHighlighter->SetShowAction(false);

    visualizer.Import(input);

    AnimationState state;
    state.SetDuration(0.5);
    state.SetHighlightLine(-1);
    state.SetSourceDataStructure(visualizer);
    state.SetAnimation([this](GUIAlgorithm srcDS, float playingAt,
                              Vector2 base) {
        auto& nodes = srcDS.GetList();
        for (GUIVisualizer::Node& node : nodes) {
            node.SetRadius(AnimationFactory::ElasticOut(playingAt) * 20);
            node.SetValueFontSize(AnimationFactory::ElasticOut(playingAt) * 24);
            node.SetLabelFontSize(AnimationFactory::ElasticOut(playingAt) * 20);
        }
        srcDS.Draw(base, playingAt, true);
        return srcDS;
    });

    animController->AddAnimation(state);
    animController->Reset();
    animController->InteractionLock();
}

#endif  // CORE_ALGORITHMS_LINKEDLIST_ALGORITHM_HPP